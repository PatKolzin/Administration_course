# Домашнее задание к занятию «Работа в терминале. Лекция 2»

## Задание

Ответьте на вопросы:

1. Какого типа команда `cd`? Попробуйте объяснить, почему она именно такого типа: опишите ход своих мыслей и поясните, если считаете, что она могла бы быть другого типа.

 ```bash
   vagrant@vagrant:~$ type cd
   cd is a shell builtin
   ```
Так как перемещаться по директориям файловой системы это базисный и минимально необходимый функционал ОС, то вполне логично что она встроена в шелл.

2. Какая альтернатива без pipe для команды `grep <some_string> <some_file> | wc -l`?   
	Изучите [документ](http://www.smallo.ruhr.de/award.html) о других подобных некорректных вариантах использования pipe.
```
grep -c
```

3. Какой процесс с PID `1` является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?

![image](https://user-images.githubusercontent.com/75835363/221348071-342d5594-b2bc-4574-a662-abf14f9c846e.png)

*PID 1 (init)*

4. Как будет выглядеть команда, которая перенаправит вывод stderr `ls` на другую сессию терминала?

```
ls <несуществующая директория> 2> /dev/pts/<номер другого терминала>
```

5. Получится ли одновременно передать команде файл на stdin и вывести её stdout в другой файл? Приведите работающий пример.

```
cat < file.txt > file2.txt
```

6. Получится ли, находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?

```
echo hello >/dev/tty2
```
Наблюдать выводимые данные возможно при переключении на соответствующий авторизованный терминал (ctrl+alt+F2)

7. Выполните команду `bash 5>&1`. К чему она приведёт? Что будет, если вы выполните `echo netology > /proc/$$/fd/5`? Почему так происходит?

`bash 5>&1` перенаправит вывод с созданного дескриптора 5 в stdout (дескриптор 1).

`echo netology > /proc/$$/fd/5` выведет в дескриптор 5 "netology", т.к. дескриптор 5 перенаправлен в stdout "netology" мы увидим в терминале.

8. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв отображение stdout на pty?  
	Напоминаем: по умолчанию через pipe передаётся только stdout команды слева от `|` на stdin команды справа.
Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.

![image](https://user-images.githubusercontent.com/75835363/221357576-1749018b-3252-459b-bf8f-d88f89e19562.png)


9. Что выведет команда `cat /proc/$$/environ`? Как ещё можно получить аналогичный по содержанию вывод?

`cat /proc/$$/environ` выведет изначальные переменные окружения для процесса запустившего данную команду.
Заменить эту команду можно printenv, env.


10. Используя `man`, опишите, что доступно по адресам `/proc/<PID>/cmdline`, `/proc/<PID>/exe`.

`/proc/<PID>/cmdline` в данном файле хранится команда запустившая процесс 
`/proc/<PID>/exe` - содержит символическую ссылку указывающую на исполняемый файл процесса загруженный в память ядра.

11. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью `/proc/cpuinfo`.

![image](https://user-images.githubusercontent.com/75835363/221358220-2c4ac9ea-e10c-4f3e-9945-3d724bf35f60.png)
*Старшая версия набора инструкций SSE 4.2*

12. При открытии нового окна терминала и `vagrant ssh` создаётся новая сессия и выделяется pty.  
	Это можно подтвердить командой `tty`, которая упоминалась в лекции 3.2.  
	
	Однако:

    ```bash
	vagrant@netology1:~$ ssh localhost 'tty'
	not a tty
    ```

	Почитайте, почему так происходит и как изменить поведение.
	
  ![image](https://user-images.githubusercontent.com/75835363/221358817-5505ac7d-15a6-440d-993f-8edc76711b6c.png)
Поведение можно поменять командой `ssh -t`, чтобы переназначить псевдотерминал.
  
13. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись `reptyr`. Например, так можно перенести в `screen` процесс, который вы запустили по ошибке в обычной SSH-сессии.

![image](https://user-images.githubusercontent.com/75835363/221362455-7f7e81db-5df0-49c7-af2b-2c4add8e69ad.png)


14. `sudo echo string > /root/new_file` не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell, который запущен без `sudo` под вашим пользователем. Для решения этой проблемы можно использовать конструкцию `echo string | sudo tee /root/new_file`. Узнайте, что делает команда `tee` и почему в отличие от `sudo echo` команда с `sudo tee` будет работать.

Будет работать т.к. в данном случае запись в файл будет осуществляться командой tee запущенной c от рута (и соответственно имеющей необходимые права).

----
