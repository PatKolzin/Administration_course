# Домашнее задание к занятию «Операционные системы. Лекция 1»


## Задание

1. **Какой системный вызов делает команда `cd`?**

    **В прошлом ДЗ вы выяснили, что `cd` не является самостоятельной  программой. Это `shell builtin`, поэтому запустить `strace` непосредственно на `cd` не получится.** **Вы можете запустить `strace` на `/bin/bash -c 'cd /tmp'`. В этом случае увидите полный список системных вызовов, которые делает сам `bash` при старте. **

    **Вам нужно найти тот единственный, который относится именно к `cd`. Обратите внимание, что `strace` выдаёт результат своей работы в поток stderr, а не в stdout.**

![image](https://user-images.githubusercontent.com/75835363/222418860-7844ec9e-b991-40e9-9d0a-66fd006bc33f.png)

Команда `cd` делает системный вызов `chdir`

2. **Попробуйте использовать команду `file` на объекты разных типов в файловой системе. Например:**

    ```bash
    vagrant@netology1:~$ file /dev/tty
    /dev/tty: character special (5/0)
    vagrant@netology1:~$ file /dev/sda
    /dev/sda: block special (8/0)
    vagrant@netology1:~$ file /bin/bash
    /bin/bash: ELF 64-bit LSB shared object, x86-64
    ```
    
    **Используя `strace`, выясните, где находится база данных `file`, на основании которой она делает свои догадки.**

![image](https://user-images.githubusercontent.com/75835363/222435796-d1259187-cf8a-4549-9cb7-8107983a527b.png)

Системный вызов openat 
*openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3* 
/usr/share/misc/magic.mgc - это и есть база данных для команды `file`
В `man file` есть описание в разделе FILES
FILES
/usr/share/misc/magic.mgc Default compiled list of magic.
/usr/share/misc/magic Directory containing default magic files.
Если грепать, то за исключением библиотек видно, что `file` обращается к файлу magic.mgc.



3. **Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удалён (deleted в lsof), но сказать сигналом приложению переоткрыть файлы или просто перезапустить приложение возможности нет. Так как приложение продолжает писать в удалённый файл, место на диске постепенно заканчивается. Основываясь на знаниях о перенаправлении потоков, предложите способ обнуления открытого удалённого файла, чтобы освободить место на файловой системе.**

![image](https://user-images.githubusercontent.com/75835363/222458576-4e7d4c3b-c2c4-4d51-8e22-c1ead400820c.png)


4. **Занимают ли зомби-процессы ресурсы в ОС (CPU, RAM, IO)?**

Зомби не занимают памяти (как процессы-сироты), но блокируют записи в таблице процессов, размер которой ограничен для каждого пользователя и системы в целом.

5. **В IO Visor BCC есть утилита `opensnoop`:**

    ```bash
    root@vagrant:~# dpkg -L bpfcc-tools | grep sbin/opensnoop
    /usr/sbin/opensnoop-bpfcc
    ```
   ![image](https://user-images.githubusercontent.com/75835363/222697847-e90243fd-10c5-4a99-947f-61bed32c917a.png)
   ![image](https://user-images.githubusercontent.com/75835363/222698002-6fc57cbd-ffd3-4a9a-9e33-905cd4522c3a.png)
    На какие файлы вы увидели вызовы группы `open` за первую секунду работы утилиты? Воспользуйтесь пакетом `bpfcc-tools` для Ubuntu 20.04. Дополнительные сведения по установке [по ссылке](https://github.com/iovisor/bcc/blob/master/INSTALL.md).

6. **Какой системный вызов использует `uname -a`? Приведите цитату из man по этому системному вызову, где описывается альтернативное местоположение в `/proc` и где можно узнать версию ядра и релиз ОС.**

![image](https://user-images.githubusercontent.com/75835363/222684890-49ca4b03-b644-4fa4-bed7-c914fd45f9d4.png)

Используется системный вызов `uname()`

Цитата из `man 2 uname`  - Part of the utsname information is also accessible via /proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}.

7. **Чем отличается последовательность команд через `;` и через `&&` в bash? Например:**

    ```bash
    root@netology1:~# test -d /tmp/some_dir; echo Hi
    Hi
    root@netology1:~# test -d /tmp/some_dir && echo Hi
    root@netology1:~#
    ```
    ; - разделитель последовательных команд, команды выполняются последовательно, не обращая внимание, успешно ли завершилась предыдущая, а && - условный оператор, используется для объединения команд таким образом, что следующая команда запускается тогда и только тогда, когда предыдущая команда завершилась без ошибок или, точнее, выйдет с кодом возврата 0.

   С использованием && вторая команда отработает только при успешном результате первой.
   
   **Есть ли смысл использовать в bash `&&`, если применить `set -e`?**

Использовать можно, но смысла особого нет, иак как с применением `set -e` оболочка завершит работу при ненулевом коде возврата команды. 

8. **Из каких опций состоит режим bash `set -euxo pipefail`, и почему его хорошо было бы использовать в сценариях?**

-e - прерывает выполнение исполнения при ошибке любой команды кроме последней
-x - вывод трейса простых команд
-u - неустановленные / не заданные параметры и переменные считаются как ошибки, с выводом в stderr текста ошибки и выполнит завершение неинтерактивного вызова
-o - pipefail возвращает код возврата последовательности команд

Повышает детализацию ошибок выполнения, а так же завершит сценарий при наличии ошибок на любом из этапов выполнения сценария.


9. **Используя `-o stat` для `ps`, определите, какой наиболее часто встречающийся статус у процессов в системе. В `man ps` изучите (`/PROCESS STATE CODES`), что значат дополнительные к основной заглавной букве статуса процессов. Его можно не учитывать при расчёте (считать S, Ss или Ssl равнозначными).**

![image](https://user-images.githubusercontent.com/75835363/222739089-a0984ba6-92a7-4434-a2c8-97dcb4f8077f.png)


Наиболее часто встречаются процессы с STAT равным S, Ss и Ssl (прерываемый сон), ожидающие дальнейшей команды/сигналов и R+ выполняющиеся в группе приоритетных.

`Ss` - неактивные процессы;
`R+` - выполняющиеся в группе приоритетных.

Дополнительные к заглавной букве - это дополнительные значения состояния процесса:
`<` - высокий приоритет;
`N` - низкий приорит;
`L` - имеет страницы, заблокированные в памяти;
`s` - является лидером сеанса;
`l` - является многопоточным;
`+` - находится в группе приоритетных процессов. 
